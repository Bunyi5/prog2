<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>JDK osztályok</title>
        <para>
            Egy olyan programot kellett írni C++-ban boost használatával amely kilistázza
            a JDK zip tartalmát. Íme  a forráskód:
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;

int main(int argc, char *argv[])
{
    path p("SrcZip");
    if(!exists(p) || !is_directory(p)) {
        cout << p << " is not a path" << endl;
        return 1;
    }
    
    int i=0;
    recursive_directory_iterator begin(p), end;
    vector<directory_entry> v(begin, end);
    for(auto& f:v) {
        if(path(f).has_extension()) {
            cout << "    -" <<path(f) .filename()<< endl;
            i++;
        } else {
            cout << f <<  endl;
        }
    }
    cout << "Összes fájl:" << i << endl;
}]]>
        </programlisting>
        <para>
            Részenként elemezve a program:
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;]]>
        </programlisting>
        <para>
            Először is includeolom a megfelelő osztályokat, közöttük a boost/filesystem.hpp,
            amely majd a path-al kapcsolatos műveletekben fog segíteni.
        </para>
        <programlisting language="c++">
<![CDATA[path p("SrcZip");
if(!exists(p) || !is_directory(p)) {
    cout << p << " is not a path" << endl;
    return 1;
}]]>
        </programlisting>
        <para>
            Megadom pathnak a mappa nevét, amelyben a kicsomagolt src.zip fájl van. Valamint
            ellenőrzöm, hogy létezik-e megadott útvonal, ha nem kiíratom, hogy nincs ilyen
            útvonal.
        </para>
        <programlisting language="c++">
<![CDATA[int i=0;
recursive_directory_iterator begin(p), end;
vector<directory_entry> v(begin, end);
for(auto& f:v) {
    if(path(f).has_extension()) {
        cout << "    -" <<path(f) .filename()<< endl;
        i++;
    } else {
        cout << f <<  endl;
    }
}
cout << "Összes fájl:" << i << endl;]]>
        </programlisting>
        <para>
            A recursive_directory_iterator egy directory_entry elemein az összes alkönyvtár
            bejegyzésén rekúrzívan iterál. Minden könyvtárbejegyzést csak egyszer látogat meg.
            Egy vectorba elmentem az összes directory_entryt. Ezt átadom egy for-each
            ciklusnak. Egy if-el megvizsgálom, hogy az éppen vizsgált elérési útvonalnak van-e
            fájl a végén. Ha van beljebb húzom és kiíratom a fájl nevét, ha nincs akkor csak
            a mappa nevét íratom ki. Az i-vel pedig az összes fájlt számlálom meg.
            A program fordítása és futtatása:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A program végeredménye:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkruncmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
            
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <algorithm>

using namespace std;

class program{
private:
	int a;
	int* b;
	
public:
	program(int elem1, int& elem2) : a(elem1), b(new int){      //konstruktor 2 paraméterrel
		cout << "\tLefutott a default konstruktor!" << endl;
		*b = elem2;
	}

	program(const program &adott){      //másoló konstruktor
		cout << "\tLefutott a másoló konstruktor!" << endl;
		a = adott.a;
		b = new int;
		*b = *adott.b;
	}

	program& operator= (program &adott){        //másoló értékadás
		cout << "\tMásoló értékadás történt!" << endl;
		a = adott.a;
		*b = *adott.b;
		return *this;
	}

	program(program && adott){      //mozgató konstruktor
		cout << "\tLefutott a mozgató konstruktor!" << endl;
		a = 0;
		b = nullptr;
		*this = move(adott);
		
	}

	program& operator= (program && adott){      //mozgató értékadás
		cout << "\tMozgató értékadás történt!" << endl;
		swap(b,adott.b);
		swap(a,adott.a);
		
		return *this;
	}

	void Print(){
		if(b!=NULL)                                      
			cout << "Az a értéke: " << a << ", A b értéke " << *b << ", és b " << b << "-re mutat\n" << endl;
		else
			cout << "Az a értéke: " << a << ", A b értéke " << b << "\n" << endl;
	}

	~program(){     //destruktor
		cout << "\tLefutott a destruktor!" << endl;
		delete b;
	}
};

int main(){
	
    int Nyolc = 8;
    int Kilenc = 9;

    cout << "Alap létrehozása 10, Nyolc értékekkel:" << endl;
    program Alap(10, Nyolc);
    cout << "Alap ertekei:" << endl;
    Alap.Print();

    cout << "\n\n----------Másoló konstruktor----------" << endl;
    cout << "Alap_masolat létrehozása Alap alapjan:" << endl;
    program Alap_masolat(Alap);
    cout << "Alap ertekei:" << endl;
    Alap.Print();
    cout << "Alap_masolat értékei" << endl;
    Alap_masolat.Print();

    cout << "\n\nUj1 létrehozása 20, Kilenc értékekkel:" << endl;
    program Uj1(20, Kilenc);
    cout << "Uj1 ertekei:" << endl;
    Uj1.Print();

    cout << "\n\n----------Másoló értékadás----------" << endl;
    cout << "Alap_masolat = Uj1:" << endl;
    Alap_masolat = Uj1;
    cout << "Uj1 ertekei:" << endl;
    Uj1.Print();
    cout << "Alap_masolat ertekei:" << endl;
    Alap_masolat.Print();

    cout << "\n\n----------Mozgató konstruktor és értékadás----------" << endl;
    cout << "Uj2 létrehozása mozgató konstruktorral:" << endl;
    program Uj2(move(Alap));
    cout << "Alap ertekei:" << endl;
    Alap.Print();
    cout << "Uj2 ertekei:" << endl;
    Uj2.Print();

      cout << "\n\nProgram vége:" << endl;

    return 0;
}]]>
        </programlisting>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Constructor1.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Hibásan implementált RSA törése</title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
            Egy olyan példát kellett készítenünk, amely egy képet tesz a Perceptron osztály
            bemenetére és nem egy értéket, hanem egy ugyanakkora méretű képet ad vissza.
            Először is nézzük meg a konstruktorunkat:
        </para>
        <programlisting language="c++">
<![CDATA[public:
  Perceptron ( int nof, ... )
  {
    n_layers = nof;

    units = new double*[n_layers];
    n_units = new int[n_layers];

    va_list vap;

    va_start ( vap, nof );

    for ( int i {0}; i < n_layers; ++i )
      {
        n_units[i] = va_arg ( vap, int );

        if ( i )
          units[i] = new double [n_units[i]];
      }

    va_end ( vap );

    weights = new double**[n_layers-1];

#ifndef RND_DEBUG
    std::random_device init;
    std::default_random_engine gen {init() };
#else
    std::default_random_engine gen;
#endif

    std::uniform_real_distribution<double> dist ( -1.0, 1.0 );

    for ( int i {1}; i < n_layers; ++i )
      {
        weights[i-1] = new double *[n_units[i]];

        for ( int j {0}; j < n_units[i]; ++j )
          {
            weights[i-1][j] = new double [n_units[i-1]];

            for ( int k {0}; k < n_units[i-1]; ++k )
              {
                weights[i-1][j][k] = dist ( gen );
              }
          }
      }
  }]]>
        </programlisting>
        <para>
            Ahogy látható a konstruktor paraméter mezőjében egy nem szokványos megadás van.
            <function>Perceptron ( int nof, ... )</function> Ezt nevezzük változó
            paraméter számú konstruktornak. Az első szám azt fogja megadni, hogy hány
            paraméter lesz még utána.
        </para>
        <programlisting language="c++">
<![CDATA[double* operator() ( double image [] )
  {

    units[0] = image;

    for ( int i {1}; i < n_layers; ++i )
      {

#ifdef CUDA_PRCPS

        cuda_layer ( i, n_units, units, weights );

#else

        #pragma omp parallel for
        for ( int j = 0; j < n_units[i]; ++j )
          {
            units[i][j] = 0.0;

            for ( int k = 0; k < n_units[i-1]; ++k )
              {
                units[i][j] += weights[i-1][j][k] * units[i-1][k];
              }

            units[i][j] = sigmoid ( units[i][j] );

          }

#endif

      }

    for (int i = 0; i < n_units[n_layers - 1]; i++) {
        image[i] = units[n_layers - 1][i];
    }
    
    return image;
    //return sigmoid ( units[n_layers - 1][0] );

  }]]>
        </programlisting>
        <para>
            Itt pedig az operator() függvény látható, amelyben csak annyit kellett
            megváltoztatni, hogy ne egy értékkel térjen vissza, hanem egy tömbbel.
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>
#include <fstream>

int main (int argc, char **argv){
    png::image <png::rgb_pixel> png_image (argv[1]);

    int size = png_image.get_width()* png_image.get_height();

    Perceptron* p = new Perceptron (3, size, 256, size);

    double* image = new double[size];

    for (int i {0}; i<png_image.get_width();++i)
        for (int j {0}; j<png_image.get_height();++j)
            image[i*png_image.get_width()+j]= png_image[i][j].red;

    double* newPNG = (*p) (image);
    
    for(int i = 0; i < png_image.get_width(); ++i)
        for(int j = 0; j < png_image.get_height(); ++j)
            png_image[i][j].green = newPNG[i*png_image.get_width()+j];

    png_image.write("output.png");

    delete p;
    delete [] image;
}]]>
        </programlisting>
        <para>
            A main metódusban először beolvassuk a képet. Létrehozzuk a size-ot, amely
            a kép pixel méretét fogja tartalmazni. Majd példányosítjuk a Perceptron
            osztályt. Itt látszik a változó paraméterű konstruktor haszna. Ezután végig
            megyünk a kép szélességén és magasságán, a megfelelő piros értékeket kiírjuk
            az image tömbbe. A második for ciklussal felülírjuk a zöld értékeket. Végül
            kimentjük az új képet és felszabadítjuk a memóriát.
        </para>
        <para>
            A program fordítása és futtatása:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="valtargcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Az eredeti és az eredményül kapott kép:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="valtargkep.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
</chapter>

