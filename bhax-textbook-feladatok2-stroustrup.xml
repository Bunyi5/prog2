<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>JDK osztályok</title>
        <para>
            Egy olyan programot kellett írni C++-ban boost használatával amely kilistázza
            a JDK zip tartalmát. Íme  a forráskód:
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;

int main(int argc, char *argv[])
{
    path p("SrcZip");
    if(!exists(p) || !is_directory(p)) {
        cout << p << " is not a path" << endl;
        return 1;
    }
    
    int i=0;
    recursive_directory_iterator begin(p), end;
    vector<directory_entry> v(begin, end);
    for(auto& f:v) {
        if(path(f).has_extension()) {
            cout << "    -" <<path(f) .filename()<< endl;
            i++;
        } else {
            cout << f <<  endl;
        }
    }
    cout << "Összes fájl:" << i << endl;
}]]>
        </programlisting>
        <para>
            Részenként elemezve a program:
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;]]>
        </programlisting>
        <para>
            Először is includeolom a megfelelő osztályokat, közöttük a boost/filesystem.hpp,
            amely majd a path-al kapcsolatos műveletekben fog segíteni.
        </para>
        <programlisting language="c++">
<![CDATA[path p("SrcZip");
if(!exists(p) || !is_directory(p)) {
    cout << p << " is not a path" << endl;
    return 1;
}]]>
        </programlisting>
        <para>
            Megadom pathnak a mappa nevét, amelyben a kicsomagolt src.zip fájl van. Valamint
            ellenőrzöm, hogy létezik-e megadott útvonal, ha nem kiíratom, hogy nincs ilyen
            útvonal.
        </para>
        <programlisting language="c++">
<![CDATA[int i=0;
recursive_directory_iterator begin(p), end;
vector<directory_entry> v(begin, end);
for(auto& f:v) {
    if(path(f).has_extension()) {
        cout << "    -" <<path(f) .filename()<< endl;
        i++;
    } else {
        cout << f <<  endl;
    }
}
cout << "Összes fájl:" << i << endl;]]>
        </programlisting>
        <para>
            A recursive_directory_iterator egy directory_entry elemein az összes alkönyvtár
            bejegyzésén rekúrzívan iterál. Minden könyvtárbejegyzést csak egyszer látogat meg.
            Egy vectorba elmentem az összes directory_entryt. Ezt átadom egy for-each
            ciklusnak. Egy if-el megvizsgálom, hogy az éppen vizsgált elérési útvonalnak van-e
            fájl a végén. Ha van beljebb húzom és kiíratom a fájl nevét, ha nincs akkor csak
            a mappa nevét íratom ki. Az i-vel pedig az összes fájlt számlálom meg.
            A program fordítása és futtatása:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A program végeredménye:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkruncmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Másoló-mozgató szemantika és Összefoglaló</title>
        <para>
            Kódcsipeteken keresztül kellett összevetni a C++11 másoló és mozgató
            szemantikáját, valamint a mozgató konstruktort a mozgató értékadásra kellett
            alapozni. Íme a teljes kód ami bemutatja mind a másoló konstruktort, másoló
            értékadást, mozgató konstruktort és mozgató értékadást:
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include <algorithm>

using namespace std;

class program{
private:
    int a;
    int* b;
    
public:
    program(int elem1, int& elem2) : a(elem1), b(new int){      //konstruktor 2 paraméterrel
        cout << "\tLefutott a default konstruktor!" << endl;
        *b = elem2;
    }

    program(const program &adott){      //másoló konstruktor
        cout << "\tLefutott a másoló konstruktor!" << endl;
        a = adott.a;
        b = new int;
        *b = *adott.b;
    }

    program& operator= (program &adott){        //másoló értékadás
        cout << "\tMásoló értékadás történt!" << endl;
        a = adott.a;
        *b = *adott.b;
        return *this;
    }

    program(program && adott){      //mozgató konstruktor
        cout << "\tLefutott a mozgató konstruktor!" << endl;
        a = 0;
        b = nullptr;
        *this = move(adott);
        
    }

    program& operator= (program && adott){      //mozgató értékadás
        cout << "\tMozgató értékadás történt!" << endl;
        swap(b,adott.b);
        swap(a,adott.a);
        
        return *this;
    }

    void Print(){
        if(b!=NULL)                                      
            cout << "Az a értéke: " << a << ", A b értéke " << *b << ", és b " << b << "-re mutat\n" << endl;
        else
            cout << "Az a értéke: " << a << ", A b értéke " << b << "\n" << endl;
    }

    ~program(){     //destruktor
        cout << "\tLefutott a destruktor!" << endl;
        delete b;
    }
};

int main(){
    
    int Nyolc = 8;
    int Kilenc = 9;

    cout << "Alap létrehozása 10, Nyolc értékekkel:" << endl;
    program Alap(10, Nyolc);
    cout << "Alap ertekei:" << endl;
    Alap.Print();

    cout << "\n\n----------Másoló konstruktor----------" << endl;
    cout << "Alap_masolat létrehozása Alap alapjan:" << endl;
    program Alap_masolat(Alap);
    cout << "Alap ertekei:" << endl;
    Alap.Print();
    cout << "Alap_masolat értékei" << endl;
    Alap_masolat.Print();

    cout << "\n\nUj1 létrehozása 20, Kilenc értékekkel:" << endl;
    program Uj1(20, Kilenc);
    cout << "Uj1 ertekei:" << endl;
    Uj1.Print();

    cout << "\n\n----------Másoló értékadás----------" << endl;
    cout << "Alap_masolat = Uj1:" << endl;
    Alap_masolat = Uj1;
    cout << "Uj1 ertekei:" << endl;
    Uj1.Print();
    cout << "Alap_masolat ertekei:" << endl;
    Alap_masolat.Print();

    cout << "\n\n----------Mozgató konstruktor és értékadás----------" << endl;
    cout << "Uj2 létrehozása mozgató konstruktorral:" << endl;
    program Uj2(move(Alap));
    cout << "Alap ertekei:" << endl;
    Alap.Print();
    cout << "Uj2 ertekei:" << endl;
    Uj2.Print();

      cout << "\n\nProgram vége:" << endl;

    return 0;
}]]>
        </programlisting>
        <para>
            De nézzük elemezve a kódot.
        </para>
        <programlisting language="c++">
<![CDATA[private:
    int a;
    int* b;]]>
        </programlisting>
        <para>
            A program class private részében először is van két változó.
            Egy alap int típusú ez lesz az "a".
            A másik egy pointer amit * jelölünk ez a "b".
        </para>
        <programlisting language="c++">
<![CDATA[program(int elem1, int& elem2) : a(elem1), b(new int){
    cout << "\tLefutott a default konstruktor!" << endl;
    *b = elem2;
}]]>
        </programlisting>
        <para>
            A legelső egy default két paraméteres konstruktor. Itt csak annyi történik, hogy
            amikor ez meghívódik akkor az "a"-t egyenlővé teszi az első elemmel, a "b"
            viszont mivel pointer jelölni kell egy *-al, így mentjük el az értékébe az
            elem2-t. A kiíratás egy nyomkövető üzenet.
        </para>
        <programlisting language="c++">
<![CDATA[program(const program &adott){
    cout << "\tLefutott a másoló konstruktor!" << endl;
    a = adott.a;
    b = new int;
    *b = *adott.b;
}]]>
        </programlisting>
        <para>
            Ezután a sorban a másoló konstruktor következik. Ezt akkor használjuk amikor
            úgy inicializálunk egy osztályt, hogy egy már kész ugyanolyan típusú osztály
            példány értékeit másoljuk át. Ez a konstruktor annyira fontos a C++-ban, hogy ha
            nem hozunk létre ilyet, automatikusan létre fog jönni egy. Azonban ezek a fordító
            által létrehozott konstruktorok csak sekély másolatot készítenek. Ez azt jelenti,
            hogy csak az eredeti objektumra való hivatkozást másolja és nem annak az értékét.
        </para>
        <para>
            Ezért ha pointerekkel és referenciákkal dolgozunk csak maga a pointer másolódik,
            ekkor kell létrehoznunk egy saját mélymásoló konstruktort. A mélymásoló
            külön memóriát foglal le a másolt információk számára. Vagyis a forrás és a
            másolat különböznek. Ha a mélymásolásnál megváltoztatjuk a másolat
            értékét akkor a forrás nem változik, nem úgy mint a sekély másolásnál. Tehát
            az egyik memóriahelyen végrehajtott módosítások nem befolyásolják a másikat.
            Ha pedig dinamikus memóriát pointerek segítségével allokálunk, akkor kell a
            felhasználó által definiált másoló konstruktor, hogy mind a két objektum különböző
            memóriahelyekre mutasson.
        </para>
        <para>
            Egy ilyen konstruktor látható fent is. A paraméterében egy objektumra vonatkozó
            referenciát kell tartalmaznia másképpen végtelen ciklus jön létre. A törzsben
            jelenleg egy nyomkövető üzenet van, egy sima int típusú érték átmásolás, valamint
            a b pointerbe másoljuk a másolandó példány b értékét.
        </para>
        <programlisting language="c++">
<![CDATA[program& operator= (program &adott){
    cout << "\tMásoló értékadás történt!" << endl;
    a = adott.a;
    *b = *adott.b;
    return *this;
}]]>
        </programlisting>
        <para>
            A másoló értékadást akkor használjuk amikor egy osztály értékeit egy másik már
            létező osztály értékeibe szeretnénk másolni. Meghívása:
            <function>osztaly1 = osztaly2</function>
            Ez is ugyanúgy mint a másoló konstruktornál automatikusan létrejön a fordításkor,
            de ugyanaz lesz a helyzet itt is csak sekély másolás történik, így ahhoz, hogy
            pointerekkel és referenciákkal tudjunk dolgozni itt is létre kell hozni egy
            saját másoló értékadást.
        </para>
        <para>
            Ebben az esetben mint a másoló konstruktornál van egy sima int érték átmásolás és
            a b pointerbe másoljuk a másolandó példány értékét.
        </para>
        <programlisting language="c++">
<![CDATA[program(program && adott){
    cout << "\tLefutott a mozgató konstruktor!" << endl;
    a = 0;
    b = nullptr;
    *this = move(adott);
    
}

program& operator= (program && adott){
    cout << "\tMozgató értékadás történt!" << endl;
    swap(b,adott.b);
    swap(a,adott.a);
    
    return *this;
}]]>
        </programlisting>
        <para>
            Míg a másoló konstruktor és másoló értékadás célja, hogy másolatot készítsen
            egyik objektumról a másikra, addig a mozgató konstruktor és értékadásé, hogy
            átruházza az értékeket egyikről a másik objektumra. Ez a művelet sokkal kevesebb
            erőforrást igényel, mint a másolás, mivel itt nem kell lemásolni az értékeket
            csak átadni neki. Eközben az eredeti elveszti a tartalmát és használhatatlanná
            válik.
        </para>
        <para> A mozgató konstruktor és értékadás definiálása analóg történik. A másoló szemantika
            esetén a paraméter egy konstans bal érték referencia, amíg a mozgató szemantikánál egy
            nem konstans jobb érték referenciáról beszélünk. Ezt láthatjuk is a programban mivel a
            referencia &amp; jellel van jelölve a paraméterben.
        </para>
        <para> A mozgató értékadás csak annyit tesz, hogy felcseréli a két példány tagjait a már
            beépített swap metódussal. A mozgató konstruktort pedig a mozgató értékadásra kellett
            alapozni. Ez úgy történik, hogy amikor meghívódik a konstruktor akkor amelyikbe mozgatni
            fogjuk az értékeket annak először kinullázzuk az értékeit, majd a <function>*this =
                move(adott);</function> sorral meghívjuk a másoló értékadás függvényt, ez felcseréli
            a példányok értékeit, így a forrás kapja a nullákat és a másik a forrás értékeit.
        </para>
        <programlisting language="c++">
<![CDATA[void Print(){
    if(b!=NULL)                                      
        cout << "Az a értéke: " << a << ", A b értéke " << *b << ", és b " << b << "-re mutat\n" << endl;
    else
        cout << "Az a értéke: " << a << ", A b értéke " << b << "\n" << endl;
}

~program(){
    cout << "\tLefutott a destruktor!" << endl;
    delete b;
}]]>
        </programlisting>
        <para> A program osztályban ezután csak egy print metódus van, hogy szebben láthassuk mi is
            történik. Az "a" értékét írjuk ki, majd a "b" értékét, majd a memóriacímet ahová
            a "b" mutat. Valamint kell még egy destruktor, ami törli a pointereket a program végén,
            ezzel memóriát szabadítva fel.
        </para>
        <programlisting language="c++">
<![CDATA[int Nyolc = 8;
int Kilenc = 9;

cout << "Alap létrehozása 10, Nyolc értékekkel:" << endl;
program Alap(10, Nyolc);
cout << "Alap ertekei:" << endl;
Alap.Print();]]>
        </programlisting>
        <para>
            A main metódusban először létrehozzuk az Alap példányt amit másolni fogunk és
            kiíratjuk az értékeit.
        </para>
        <programlisting language="c++">
<![CDATA[cout << "\n\n----------Másoló konstruktor----------" << endl;
cout << "Alap_masolat létrehozása Alap alapjan:" << endl;
program Alap_masolat(Alap);
cout << "Alap ertekei:" << endl;
Alap.Print();
cout << "Alap_masolat értékei" << endl;
Alap_masolat.Print();]]>
        </programlisting>
        <para>
            Ezután lemásoljuk az Alap példányt az Alap_masolatba és kiíratjuk az értékeiket.
        </para>
        <programlisting language="c++">
<![CDATA[cout << "\n\nUj1 létrehozása 20, Kilenc értékekkel:" << endl;
program Uj1(20, Kilenc);
cout << "Uj1 ertekei:" << endl;
Uj1.Print();

cout << "\n\n----------Másoló értékadás----------" << endl;
cout << "Alap_masolat = Uj1:" << endl;
Alap_masolat = Uj1;
cout << "Uj1 ertekei:" << endl;
Uj1.Print();
cout << "Alap_masolat ertekei:" << endl;
Alap_masolat.Print();]]>
        </programlisting>
        <para>
            Létrehozunk egy Uj1 nevű példányt, amibe másoló értékadással átmásoljuk az
            Alap_masolat értékeit.
        </para>
        <programlisting language="c++">
<![CDATA[cout << "\n\n----------Mozgató konstruktor és értékadás----------" << endl;
cout << "Uj2 létrehozása mozgató konstruktorral:" << endl;
program Uj2(move(Alap));
cout << "Alap ertekei:" << endl;
Alap.Print();
cout << "Uj2 ertekei:" << endl;
Uj2.Print();]]>
        </programlisting>
        <para>
            Már csak a mozgató konstruktor és értékadás maradt. Ezzel a sorral:
            <function>program Uj2(move(Alap));</function> híjuk meg a konstruktort.
            Mivel a beépített move függvény az Alapból jobb érték referenciát hoz létre,
            így tudjuk meghívni.
        </para>
        <para>
            A program futás után:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Constructor1.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogyan látszik a másoló konstruktornál az értékek ugyanazok a másolat példányánál,
            de a memória cím más. A másoló értékadásnál ugyanez látható. A mozgató konstruktornál
            és értékadásnál pedig az látszik, hogy a forrást nullára állítottuk és az Uj2
            kapta meg az értékeket.
        </para>
        <para>
            Ahogy látszik, ha jól megtanuljuk az alapokat nem okozhat nehézséget ezeknek
            a konstruktoroknak és értékadásoknak a használata, sőt megkönnyíthetik az egyes
            programok működését ha megfelelően használjuk őket.
        </para>
    </section>
    
    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
            Egy olyan példát kellett készítenünk, amely egy képet tesz a Perceptron osztály
            bemenetére és nem egy értéket, hanem egy ugyanakkora méretű képet ad vissza.
            Először is nézzük meg a konstruktorunkat:
        </para>
        <programlisting language="c++">
<![CDATA[public:
  Perceptron ( int nof, ... )
  {
    n_layers = nof;

    units = new double*[n_layers];
    n_units = new int[n_layers];

    va_list vap;

    va_start ( vap, nof );

    for ( int i {0}; i < n_layers; ++i )
      {
        n_units[i] = va_arg ( vap, int );

        if ( i )
          units[i] = new double [n_units[i]];
      }

    va_end ( vap );

    weights = new double**[n_layers-1];

#ifndef RND_DEBUG
    std::random_device init;
    std::default_random_engine gen {init() };
#else
    std::default_random_engine gen;
#endif

    std::uniform_real_distribution<double> dist ( -1.0, 1.0 );

    for ( int i {1}; i < n_layers; ++i )
      {
        weights[i-1] = new double *[n_units[i]];

        for ( int j {0}; j < n_units[i]; ++j )
          {
            weights[i-1][j] = new double [n_units[i-1]];

            for ( int k {0}; k < n_units[i-1]; ++k )
              {
                weights[i-1][j][k] = dist ( gen );
              }
          }
      }
  }]]>
        </programlisting>
        <para>
            Ahogy látható a konstruktor paraméter mezőjében egy nem szokványos megadás van.
            <function>Perceptron ( int nof, ... )</function> Ezt nevezzük változó
            paraméter számú konstruktornak. Az első szám azt fogja megadni, hogy hány
            paraméter lesz még utána.
        </para>
        <programlisting language="c++">
<![CDATA[double* operator() ( double image [] )
  {

    units[0] = image;

    for ( int i {1}; i < n_layers; ++i )
      {

#ifdef CUDA_PRCPS

        cuda_layer ( i, n_units, units, weights );

#else

        #pragma omp parallel for
        for ( int j = 0; j < n_units[i]; ++j )
          {
            units[i][j] = 0.0;

            for ( int k = 0; k < n_units[i-1]; ++k )
              {
                units[i][j] += weights[i-1][j][k] * units[i-1][k];
              }

            units[i][j] = sigmoid ( units[i][j] );

          }

#endif

      }

    for (int i = 0; i < n_units[n_layers - 1]; i++) {
        image[i] = units[n_layers - 1][i];
    }
    
    return image;
    //return sigmoid ( units[n_layers - 1][0] );

  }]]>
        </programlisting>
        <para>
            Itt pedig az operator() függvény látható, amelyben csak annyit kellett
            megváltoztatni, hogy ne egy értékkel térjen vissza, hanem egy tömbbel.
        </para>
        <programlisting language="c++">
<![CDATA[#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>
#include <fstream>

int main (int argc, char **argv){
    png::image <png::rgb_pixel> png_image (argv[1]);

    int size = png_image.get_width()* png_image.get_height();

    Perceptron* p = new Perceptron (3, size, 256, size);

    double* image = new double[size];

    for (int i {0}; i<png_image.get_width();++i)
        for (int j {0}; j<png_image.get_height();++j)
            image[i*png_image.get_width()+j]= png_image[i][j].red;

    double* newPNG = (*p) (image);
    
    for(int i = 0; i < png_image.get_width(); ++i)
        for(int j = 0; j < png_image.get_height(); ++j)
            png_image[i][j].green = newPNG[i*png_image.get_width()+j];

    png_image.write("output.png");

    delete p;
    delete [] image;
}]]>
        </programlisting>
        <para>
            A main metódusban először beolvassuk a képet. Létrehozzuk a size-ot, amely
            a kép pixel méretét fogja tartalmazni. Majd példányosítjuk a Perceptron
            osztályt. Itt látszik a változó paraméterű konstruktor haszna.
            Mivel több szűrő szintet tudunk használni. Az első szám, jelen esetben ez 3
            megadja, hogy hány szint lesz. A többi szám minden szinthez a unit-ok számát
            tartalmazza. Ezt mentjük, majd el az n_units tömmbe és létrehozunk még egy
            számára megfelelő méretű double tömböt is. Ezután feltöltjük a weights-et
            az értékeknek megfelelően. Ezután végig
            megyünk a kép szélességén és magasságán, a megfelelő piros értékeket kiírjuk
            az image tömbbe. A második for ciklussal felülírjuk a zöld értékeket. Végül
            kimentjük az új képet és felszabadítjuk a memóriát.
        </para>
        <para>
            A program fordítása és futtatása:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="valtargcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Az eredeti és az eredményül kapott kép:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="valtargkep.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
</chapter>
