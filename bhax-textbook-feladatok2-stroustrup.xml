<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>JDK osztályok</title>
        <para>
            Egy olyan programot kellett írni C++-ban boost használatával amely kilistázza
            a JDK zip tartalmát. Íme  a forráskód:
        </para>
        <programlisting>
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;

int main(int argc, char *argv[])
{
    path p("SrcZip");
    if(!exists(p) || !is_directory(p)) {
        cout << p << " is not a path" << endl;
        return 1;
    }
    
    int i=0;
    recursive_directory_iterator begin(p), end;
    vector<directory_entry> v(begin, end);
    for(auto& f:v) {
        if(path(f).has_extension()) {
            cout << "    -" <<path(f) .filename()<< endl;
            i++;
        } else {
            cout << f <<  endl;
        }
    }
    cout << "Összes fájl:" << i << endl;
}]]>
        </programlisting>
        <para>
            Részenként elemezve a program:
        </para>
        <programlisting>
<![CDATA[#include <iostream>
#include <vector>
#include <boost/filesystem.hpp>

using namespace std;
using namespace boost::filesystem;]]>
        </programlisting>
        <para>
            Először is includeolom a megfelelő osztályokat, közöttük a boost/filesystem.hpp,
            amely majd a path-al kapcsolatos műveletekben fog segíteni.
        </para>
        <programlisting>
<![CDATA[path p("SrcZip");
if(!exists(p) || !is_directory(p)) {
    cout << p << " is not a path" << endl;
    return 1;
}]]>
        </programlisting>
        <para>
            Megadom pathnak a mappa nevét, amelyben a kicsomagolt src.zip fájl van. Valamint
            ellenőrzöm, hogy létezik-e megadott útvonal, ha nem kiíratom, hogy nincs ilyen
            útvonal.
        </para>
        <programlisting>
<![CDATA[int i=0;
recursive_directory_iterator begin(p), end;
vector<directory_entry> v(begin, end);
for(auto& f:v) {
    if(path(f).has_extension()) {
        cout << "    -" <<path(f) .filename()<< endl;
        i++;
    } else {
        cout << f <<  endl;
    }
}
cout << "Összes fájl:" << i << endl;]]>
        </programlisting>
        <para>
            A recursive_directory_iterator egy directory_entry elemein az összes alkönyvtár
            bejegyzésén rekúrzívan iterál. Minden könyvtárbejegyzést csak egyszer látogat meg.
            Egy vectorba elmentem az összes directory_entryt. Ezt átadom egy for-each
            ciklusnak. Egy if-el megvizsgálom, hogy az éppen vizsgált elérési útvonalnak van-e
            fájl a végén. Ha van beljebb húzom és kiíratom a fájl nevét, ha nincs akkor csak
            a mappa nevét íratom ki. Az i-vel pedig az összes fájlt számlálom meg.
            A program fordítása és futtatása:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A program végeredménye:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="jdkruncmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>Hibásan implementált RSA törése</title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
            
        </para>
    </section>
</chapter>

