<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>
            Liskov helyettesítés sértése
        </title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>
            Szülő-gyerek
        </title>
        <para> Ennek a feladatnak a megoldásához tisztázni kell az öröklődés és a polimorfizmus
            fogalmát. Az öröklődés az, amikor egy osztályt egy már létező osztály kiterjesztésével
            definiálunk. Ekkor a már létező osztály lesz az ős- vagy szülőosztály. Az osztály amit
            pedig kiterjesztettünk leszármazott vagy gyermekosztálynak nevezzük. A létrejött utód
            egy új osztály lesz, amely örökli az ős metódusait, tagváltozóit. A public, protected,
            private kulcsszavakkal lehet megadni, hogy a gyermek melyik metódusokat, változókat
            lássa. A public-al rendelkezőket mindenki használhatja, a protected-et csak az ős
            leszármazottai. A private tagot csak az az osztály, amelyben létrehozták a tagot. </para>
        <para>
        A polimorfizmus lényege az, hogy mivel a gyermekosztály örökölt minden metódust és
        tagváltozót így egy olyan környezetben ahol az őst lehet használni a gyermeket is.
        </para>
        <para>Példa arra, hogy az ősön keresztül csak az ős üzenetei küldhetőek. Javaban:</para>
        <programlisting language="java">
<![CDATA[class Szulo {
    void szulometodus() {
        System.out.println("Szulo vagyok!");
    }
}

class Gyerek extends Szulo {
    void gyerekmetodus() {
        System.out.println("Gyerek vagyok!");
    }
}

class Szulo_Gyerek {
    public static void main(String[] args) {
    Szulo valaki = new Gyerek();
    
    valaki.szulometodus();
    valaki.gyerekmetodus(); //Nem látja a gyermekmetódusát!
    }
}]]>
        </programlisting>
        <mediaobject>
            <imageobject>
                <imagedata fileref="szulogyerekjavacmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogy a console-on is látszik a program nem látja a gyermekmetódusát, azoban a
            gyermek látja a szülő metódusát.
        </para>
        <para>
            C++-ban:
        </para>
        <programlisting>
<![CDATA[#include <iostream>

class Szulo {
public:
    void szulometodus() {
        std::cout << "Szulo vagyok!" << std::endl;
    }
};

class Gyerek : public Szulo {
public:
    void gyerekmetodus() {
        std::cout << "Gyerek vagyok!" << std::endl;
    }
};

int main() {
    Szulo* valaki = new Gyerek();

    valaki->szulometodus();
    valaki->gyerekmetodus(); //Nem látja a gyermekmetódusát!
}]]>
        </programlisting>
        <mediaobject>
            <imageobject>
                <imagedata fileref="szulogyerekcppcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Itt is ugyanúgy error kapunk, mivel hiába castoltuk a gyermeket szülővé az
            nem éri el a gyermek metódusát.
        </para>
    </section>
    
    <section>
        <title>
            Anti OO
        </title>
        <para> Össze kellett hasonlítani a BBP algoritmus kód futási idejét C, C++, Java és C#
            nyelven. Egy virtuális linux gépen futattam a kódokat. Ilyen eredményt kaptam:</para>
        <para>
            <table>
                <title>Összehasonlítás</title>
                <tgroup cols="5">
                    <colspec colname="c1"/>
                    <colspec colname="c2"/>
                    <colspec colname="c3"/>
                    <colspec colname="c4"/>
                    <colspec colname="c5"/>
                    <thead>
                        <row>
                            <entry></entry>
                            <entry>C</entry>
                            <entry>C++</entry>
                            <entry>Java</entry>
                            <entry>C#</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>10^6</entry>
                            <entry>3.051</entry>
                            <entry>2.823</entry>
                            <entry>2.575</entry>
                            <entry>2.617</entry>
                        </row>
                        <row>
                            <entry>10^7</entry>
                            <entry>34.460</entry>
                            <entry>33.332</entry>
                            <entry>28.978</entry>
                            <entry>30.589</entry>
                        </row>
                        <row>
                            <entry>10^8</entry>
                            <entry>385.376</entry>
                            <entry>386.714</entry>
                            <entry>338.139</entry>
                            <entry>353.068</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <para> Ahogy látszik a C nyelv volt a leglassabb. Ez várható volt, hisz ez a legöregebb
            nyelv a négy közül. Leggyorsabb volt a Java kód, amely a 10^8 pozíciónál 10 másodperccel
            leelőzte a C# is. Több oka is van, hogy a Java legyőzött mindenkit. Elsőnek lehet
            mondani, hogy a memória kiosztást sokkal jobban kezeli, mint a többi nyelv. Valamint a
            JVM jobban optimalizálja a metódus hívásokat. Futás időben dinamikus elemzést tud
            végezni, hogy mire van szükség és mire nem, így gyorsabb működést képes nyújtani, mint
            egy C++ fordítóprogram. </para>
    </section>
    
    <section>
        <title>
            Hello, Android!
        </title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>
            Ciklomantikus komplexitás
        </title>
        <para>
            Ebben a feladatban ki kellett számolnunk valamelyik programunk függvényeinek
            ciklomantikus komplexitását. Ezt én egy online program segítségével oldottam
            meg, a Lizard-dal. A BBP java kódját elemzte a program. Íme:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="lizard1.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Egyszerűen csak ki kell választanunk a forráskód nyelvét, majd beillesztenünk magát
            a kódot.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="lizard2.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A végeredményen a számok minél kissebbek annál jobb, hiszen ha túl bonyolultak
            a függvények nehezen olvasható a program.
        </para>
        <para>
            Számítása a gráfelméleten alapul. A forráskód alapján határozza meg
            az egyes függvények ciklomantikus komplexitását. Ez a független utak számát
            jelenti, hogy a program mennyire bonyolult vezérlési szempontból.
            Két út akkor számít függetlennek, ha mindkettőben van olyan pont, amely
            nem eleme a másiknak.
        </para>
    </section>
    
</chapter>
