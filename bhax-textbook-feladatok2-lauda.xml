<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Port scan</title>
        <para>
            A kivételkezelésre kellett rámutatni ebben a programkódban:
        </para>
        <programlisting language="java">
<![CDATA[public class KapuSzkenner {
    
    public static void main(String[] args) {
        
        for(int i=0; i<1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");
                
            }
    }
    
}]]>
        </programlisting>
        <para>
            A kivételkezelés egy olyan programozási mechanizmus, amelynek során
            kezeljük a program futását megakadályozó eseményt. Ha egy kivétel megszakítja a
            normál végrehajtási folyamatot akkor általában végrehajt egy előre regisztrált
            kivételkezelőt. A végrehajtás részletei attól függenek, hogy hardveres vagy szoftveres
            kivételről van-e szó. Néhány kivételt, általában szoftvereset annyira szépen lehet
            kezelni, hogy folytatni lehet a programot ott ahol megszakadt.
        </para>
        <para>
            Ez a pár soros program arra jó, hogy megnézzük melyik portok vannak figyelve.
            A program úgy működik, hogy parancssori argumentumként megkapja a gépet és
            annak az 1024 alatti portjain megpróbál TCP kapcsolatot kialakítani.
            Ha ez sikerül akkor a program kiírja a port nevét és azt, hogy figyeli, majd
            bezárja socketet. Azonban ha nem sikerül, akkor jön be a hibakeresés a képbe.
        </para>
        <programlisting language="java"><![CDATA[java.net.Socket socket = new java.net.Socket(args[0], i);]]></programlisting>
        <para>
            Ezzel a sorral próbál TCP kapcsolatot kialakítani, ha ez nem sikerül
            akkor IOException-t fog dobni. A catch ág ezt a kivételt elkapja és
            kiírja, hogy a port nincs figyelve. JDK forrásban így néz ki, látható,
            hogy ez a függvény két kivételt dobhat UnknownHostException-t és
            IOException-t.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="portscanjdk.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Futtatáskor csak egy portra figyelt:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="portscancmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Android Játék</title>
        <para>
            A feladatban egy Android játékot kellett írni. Én egy High-Low Game-t
            írtam. Íme a kód:
        </para>
        <programlisting language="java">
<![CDATA[public class MainActivity extends AppCompatActivity {
    private EditText txtGuess;
    private Button btnGuess;
    private TextView lblOutput;
    private int theNumber;
    private int numberOfTries = 0;

    public void checkGuess() {
        String guessText = txtGuess.getText().toString();
        String message = "";
        try {
            int guess = Integer.parseInt(guessText);
            if (guess < theNumber) {
                message = guess + " is too low. Try again.";
                Toast.makeText(MainActivity.this,
                        6 - numberOfTries + " tries left",Toast.LENGTH_SHORT).show();
            } else if (guess > theNumber) {
                message = guess + " is too high. Try again.";
                Toast.makeText(MainActivity.this,
                        6 - numberOfTries + " tries left", Toast.LENGTH_SHORT).show();
            }
            numberOfTries++;
            if (guess == theNumber) {
                message = guess + " is correct. You win after " + numberOfTries + " tries!";
                Toast.makeText(MainActivity.this, message, Toast.LENGTH_LONG).show();
                newGame();
            }
            if (numberOfTries == 7) {
                message = "You lose! The number was " + theNumber + ".";
                Toast.makeText(MainActivity.this, message, Toast.LENGTH_LONG).show();
                newGame();
            }
        } catch (Exception e) {
            message = "Enter a whole number between 1 and 100.";
        } finally {
            lblOutput.setText(message);
            txtGuess.requestFocus();
            txtGuess.selectAll();
        }
    }

    public void newGame() {
        theNumber = (int) (Math.random() * 100 + 1);
        numberOfTries = 0;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        txtGuess = findViewById(R.id.txtGuess);
        btnGuess = findViewById(R.id.btnGuess);
        lblOutput = findViewById(R.id.lblOutput);

        newGame();
        btnGuess.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                    checkGuess();
            }
        });
        txtGuess.setOnEditorActionListener(new TextView.OnEditorActionListener() {
            @Override
            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
                checkGuess();
                return true;
            }
        });
    }]]>
        </programlisting>
        <para>De nézzük részekre bontva a kódot.</para>
        <programlisting language="java">
<![CDATA[private EditText txtGuess;
private Button btnGuess;
private TextView lblOutput;
private int theNumber;
private int numberOfTries = 0;]]>
        </programlisting>
        <para>
            Először is létrehozom az osztály private változóit. A txtGuess-ben
            fogom megkapni a felhasználó által tippelt számot. A btnGuess-el
            fogom gombnyomásra ellenőrizni a megadott számot. Az lblOutput-tal
            pedig tudtára adom a felhasználónak, hogy alá vagy fölé lőtt vagy
            pontosan eltalálta a számot. A theNumber-ben fogom tárolni a helyes
            számot és a numberOfTries-al fogom számolni, hány lehetősége van még
            a felhasználónak kitalálni a számot.
        </para>
        <programlisting language="java">
<![CDATA[@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    txtGuess = findViewById(R.id.txtGuess);
    btnGuess = findViewById(R.id.btnGuess);
    lblOutput = findViewById(R.id.lblOutput);

    newGame();
    btnGuess.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
                checkGuess();
        }
    });
    txtGuess.setOnEditorActionListener(new TextView.OnEditorActionListener() {
        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            checkGuess();
            return true;
        }
    });
}]]>
        </programlisting>
        <para>
            A program futttásakor az onCreate metódus fog legelőször futni.
            Itt a txtGuess, btnGuess, lblOutput változókhoz hozzákapcsolom a
            GUI-ban a részüket. Majd hozzáadok két Listener-t. Az egyik a Guess!
            gombra fog figyelni, hogy ha megnyomják akkor ellenőrizze le a
            tippelt szám helyes-e. A setOnEditorActionListener azt figyeli, ha
            a szám begépelése után a pipára kattintunk akkor is ellenőrizze a
            helyességet. A newGame() metódussal pedig elindítjuk a játékot.
        </para>
        <programlisting language="java">
<![CDATA[public void newGame() {
    theNumber = (int) (Math.random() * 100 + 1);
    numberOfTries = 0;
}]]>
        </programlisting>
        <para>
            A newGame() a TheNumber-be kimenti a kitalálandó számot és lenullázza
            a probálkozások számát.
        </para>
        <programlisting language="java">
<![CDATA[public void checkGuess() {
    String guessText = txtGuess.getText().toString();
    String message = "";
    try {
        int guess = Integer.parseInt(guessText);
        if (guess < theNumber) {
            message = guess + " is too low. Try again.";
            Toast.makeText(MainActivity.this,
                    6 - numberOfTries + " tries left",Toast.LENGTH_SHORT).show();
        } else if (guess > theNumber) {
            message = guess + " is too high. Try again.";
            Toast.makeText(MainActivity.this,
                    6 - numberOfTries + " tries left", Toast.LENGTH_SHORT).show();
        }
        numberOfTries++;
        if (guess == theNumber) {
            message = guess + " is correct. You win after " + numberOfTries + " tries!";
            Toast.makeText(MainActivity.this, message, Toast.LENGTH_LONG).show();
            newGame();
        }
        if (numberOfTries == 7) {
            message = "You lose! The number was " + theNumber + ".";
            Toast.makeText(MainActivity.this, message, Toast.LENGTH_LONG).show();
            newGame();
        }
    } catch (Exception e) {
        message = "Enter a whole number between 1 and 100.";
    } finally {
        lblOutput.setText(message);
        txtGuess.requestFocus();
        txtGuess.selectAll();
    }
}]]>
        </programlisting>
        <para>
            A checkGuess() metódusban a guessText String típusú változóba kimentem
            a felhasználó által megadott számot és egy message változót létrehozok,
            ebben fogok visszaadni valamilyen üzenetet a felhasználónak.
            A try-on belül nézem meg, hogy a szám nagyobb, kissebb vagy éppen
            egyenlő és ehhez képest adok vissza üzenetet. Ha a felhasználó
            nem számot vagy semmit sem adott meg az kivételt eredményez és a
            catch blokk ezt elkapja. Minden próbálkozás után kiírom egy popup
            üzenetben mennyi próbálkozás maradt még, ha elfogy a 7 próba a
            felhasználó vesztett és új játék kezdődik.
        </para>
        <para>
            Képek a játékról:
        </para>
        <mediaobject>
            <imageobject>
                  <imagedata fileref="android1.png" scale="25"></imagedata>
            </imageobject>
        </mediaobject>
        <mediaobject>
            <imageobject>
                <imagedata fileref="android2.png" scale="25"></imagedata>
            </imageobject>
        </mediaobject>

    </section>
    
    <section>
        <title>Junit teszt</title>
        <para>
            Egy binfa példát kellett junit tesztbe beledolgozni. Először
            kiszámoltam az "abc" karakterek bináris kódját:
            <function>011000010110001001100011</function>.
            Ezután megrajzoltam a fát, kiszámoltam az átlagot, a mélységet és a
            szórást.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="junit1.jpg" scale="19"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Miután ezt megcsináltam JUnit teszt segítségével ellenőrizni kellett
            Junit teszttel, hogy helyesek-e az értékek amiket kézzel számoltam.
        </para>
        <para>
            Mi is az a JUnit? A JUnit egy keretrendszer a Java programozási
            nyelvhez. A JUnit-ot egy osztály tesztelésére használják.
            Minden tesztelés egy @Test annotációval kezdődik. Egy Assert típusú
            metódust kell használni, hogy összevessük a várható eredményt a
            valós eredménnyel.
        </para>
        <para>
            Így teszteltem a Binfában a mélységet, átlagot és szórást:
        </para>
        <programlisting language="java">
<![CDATA[import org.junit.jupiter.api.Test;

class LZWBinFaTest {
	LZWBinFa binfa = new LZWBinFa();

	@Test
	void test() {
		for (char c : "011000010110001001100011".toCharArray())
			binfa.egyBitFeldolg(c);
		
		org.junit.Assert.assertEquals(4, binfa.getMelyseg(), 0.0);
		org.junit.Assert.assertEquals(3, binfa.getAtlag(), 0.001);
		org.junit.Assert.assertEquals(0.81649, binfa.getSzoras(), 0.0001);
	}

}]]>
        </programlisting>
        <para>
            Ahogy a képen látszik sikeresn tesztelte az értékeket és nem dobott
            hibát.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="junit2.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
</chapter>

