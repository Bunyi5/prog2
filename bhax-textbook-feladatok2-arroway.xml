<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>OO szemlélet</title>
        <para>
            A polártranszformációs generátor egy széles körben elterjedt random generátor.
            Olyannyira elterjedt formája ez a random szám generálásnak, hogy a 
            Java.util.Random osztály is ezt a módszert alkalmazza.
        </para>
        <para>
            Íme a Java kód teljes egészében:
        </para>
        <programlisting language="java">
        <![CDATA[
public class PolarGenerator {

    boolean nincsTarolt = true;
    double tarolt;

    public PolarGenerator() {
        nincsTarolt = true;
    }

    public double kovetkezo() {
        if(nincsTarolt) {
            double u1, u2, v1, v2, w;
            do {
                u1 = Math.random();
                u2 = Math.random();

                v1 = 2*u1 - 1;
                v2 = 2*u2 - 1;

                w = v1*v1 + v2*v2;
                
            } while(w > 1);

            double r = Math.sqrt((-2*Math.log(w))/w);

            tarolt = r*v2;
            nincsTarolt = !nincsTarolt;

            return r*v1;
        } else {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }


    public static void main(String[] args) {

        PolarGenerator g = new PolarGenerator();

        for(int i=0; i<10; ++i)
            System.out.println(g.kovetkezo());
    }
}
        ]]>
        </programlisting>
        <para>
            A következő sorokban részenként magyarázom el mi történik a kódban.
        </para>
        <programlisting language="java">
        <![CDATA[
boolean nincsTarolt = true;
double tarolt;
        ]]>
        </programlisting>
        <para>
            A PolárGenerátor classban létrehozunk két változót. Az egyik boolean típusú, amely
            azt fogja megmondani, hogy éppen van-e tárolt értékünk. A másik maga a tárolt értéket
            tartalmazza, amit korábban kiszámítottunk.
        </para>
        <programlisting language="java">
        <![CDATA[
public PolarGenerator() {
    nincsTarolt = true;
}
        ]]>
        </programlisting>
        <para>
            Ez a class publikus konstruktora, amely a nincsTarolt-at igazra állítja.
            Erre azért van szükség, hogy tudjuk éppen van-e tárolt érték vagy nincs.
        </para>
        <programlisting language="java">
        <![CDATA[
public double kovetkezo() {
    if(nincsTarolt) {
        double u1, u2, v1, v2, w;
        do {
            u1 = Math.random();
            u2 = Math.random();

            v1 = 2*u1 - 1;
            v2 = 2*u2 - 1;

            w = v1*v1 + v2*v2;
                
        } while(w > 1);

        double r = Math.sqrt((-2*Math.log(w))/w);

        tarolt = r*v2;
        nincsTarolt = !nincsTarolt;

        return r*v1;
    } else {
        nincsTarolt = !nincsTarolt;
        return tarolt;
    }
}
        ]]>
        </programlisting>
        <para>
            Ez a program lelke ahol a kovetkezo() metódus végzi a meghatározó 
            számítást. Ha a nincsTarolt értéke igaz, akkor számol két random értéket.
            Az egyiket elmenti a tarolt változóba, a másikat pedig visszaadja.
            Amennyiban a nincsTarolt értéke hamis, akkor pedig a tárolt értéket fogja
            visszaadni.
        </para>
        <programlisting language="java">
        <![CDATA[
public static void main(String[] args) {

    PolarGenerator g = new PolarGenerator();

    for(int i=0; i<10; ++i)
        System.out.println(g.kovetkezo());
}
        ]]>
        </programlisting>
        <para>
            A main metódusal indul el a program. Itt példányosítjuk a PolárGenerátor 
            classot. Ezután egy for ciklussal 10-szer kiíratjuk a meghívott kovetkezo()
            metódus értékét. Minden második érték a tarolt változóból visszadott
            érték lesz.
            Ezeket az értékeket generálta nekem:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="polarjavacmd.jpg"/>
                </imageobject>
        </mediaobject>
        <para>
            Az érdekesség az még itt, hogy a Java fejlesztők egy nagyon hasonló
            módon oldották meg a java.util.Random osztályban a Random szám
            generálást. Íme:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="polarjavaRandom.jpg"/>
                </imageobject>
        </mediaobject>
        <para>
            C++-ban így néz ki a teljes kód:
        </para>
        <programlisting>
        <![CDATA[
#include <iostream>
#include <tgmath.h>
#include <cstdlib>
#include <time.h>

using namespace std;

class PolarGenerator {
private:
    bool nincsTarolt;
    double tarolt;

public:
    PolarGenerator() {
        nincsTarolt = true;
        srand (time(NULL));
    }


    double kovetkezo() {
        if (nincsTarolt) {
            double u1, u2, v1, v2, w;

            do {
                u1 = rand() / (RAND_MAX + 1.0);
                u2 = rand() / (RAND_MAX + 1.0);

                v1 = 2 * u1 - 1;
                v2 = 2 * u2 - 1;

                w = v1 * v1 + v2 * v2;
            } while (w > 1);

            double r = sqrt((-2 * log(w)) / w);
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
        }
        else {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }
};


int main(int argc, char** argv) {
    PolarGenerator g;

    for (int i = 0; i < 10; ++i)
        cout << g.kovetkezo() << endl;

    return 0;
}
        ]]>
        </programlisting>
        <para>
            A következő sorokban részenként magyarázom el mi történik a kódban.
        </para>
        <programlisting>
        <![CDATA[
private:
    bool nincsTarolt;
    double tarolt;
        ]]>
        </programlisting>
        <para>
            Ez a Polárgenerátor class private része. Ez tartalmaz egy bool és egy double
            típusú változót. Ezek a változók csak az osztályon belül lesznek elérhetőek.
        </para>
        <programlisting>
        <![CDATA[
public:
    PolarGenerator() {
        nincsTarolt = true;
        srand (time(NULL));
    }


    double kovetkezo() {
        if (nincsTarolt) {
            double u1, u2, v1, v2, w;

            do {
                u1 = rand() / (RAND_MAX + 1.0);
                u2 = rand() / (RAND_MAX + 1.0);

                v1 = 2 * u1 - 1;
                v2 = 2 * u2 - 1;

                w = v1 * v1 + v2 * v2;
            } while (w > 1);

            double r = sqrt((-2 * log(w)) / w);
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
        }
        else {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }
};
        ]]>
        </programlisting>
        <para>
            Ez pedig a class public része, amelyben a változók és metódusok
            példányosítás után elérhetőek az osztályon kívül is.
        </para>
        <programlisting>
        <![CDATA[
PolarGenerator() {
    nincsTarolt = true;
    srand (time(NULL));
}
        ]]>
        </programlisting>
        <para>
            Az osztály nevével megegyező metódust konstruktornak nevezzük. Az ebben
            lévő kódok példányosításkor hajtódnak végre.
        </para>
        <programlisting>
        <![CDATA[
double kovetkezo() {
    if (nincsTarolt) {
        double u1, u2, v1, v2, w;

        do {
            u1 = rand() / (RAND_MAX + 1.0);
            u2 = rand() / (RAND_MAX + 1.0);

            v1 = 2 * u1 - 1;
            v2 = 2 * u2 - 1;

            w = v1 * v1 + v2 * v2;
        } while (w > 1);

        double r = sqrt((-2 * log(w)) / w);
        tarolt = r * v2;
        nincsTarolt = !nincsTarolt;

        return r * v1;
    }
    else {
        nincsTarolt = !nincsTarolt;
        return tarolt;
    }
}
        ]]>
        </programlisting>
        <para>
            A kovetkezo metódusban szinte semmilyen lényegi eltérés nincs a Java kódhoz
            képest. Ugyanaz történik ha nincsTarolt igaz akkor generál randomot, ha
            pedig hamis, akkor visszaadja az eltárolt értéket.
        </para>
        <programlisting>
        <![CDATA[
int main(int argc, char** argv) {
    PolarGenerator g;

    for (int i = 0; i < 10; ++i)
        cout << g.kovetkezo() << endl;

    return 0;
}
        ]]>
        </programlisting>
        <para>
            A main metódusban szintén, mint a Javanál példányosítunk és egy for
            ciklussal 10-szer visszadjuk a kovetkezo() metódus értékét.
        </para>
        <para>
            C++-ban generált értékek:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="polarcppcmd.jpg"/>
                </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>"Gagyi"</title>
        <programlisting>
<![CDATA[while (x <=t && x>=t && t !=x);]]>
        </programlisting>
        <para>
            Erre a tesztkérdésre kellett választ adnunk, hogy bizonyos számoknál
            miért jön létre végtelen ciklus és bizonyosnál miért nem.
        </para>
        <programlisting language="java">
        <![CDATA[
public class Gagyi {

    public static void main (String[]args){

        Integer x = -128;
        Integer t = -128;

    while (x <= t && x >= t && t != x);
    }
}
        ]]>
        </programlisting>
        <para>
            Például itt -128-nál nem jön létre végtelen ciklus.
        </para>
        <programlisting language="java">
        <![CDATA[
public class GagyiInfinity {

    public static void main (String[]args){

       Integer x = -129;
       Integer t = -129;

    while (x <= t && x >= t && t != x);
    }
}
        ]]>
        </programlisting>
        <para>
            Azonban -129-el már végtelen ciklus jön létre.
        </para>
        <programlisting language="java">
        <![CDATA[
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
        ]]>
        </programlisting>
        <para>
            A válasz, hogy miért jön létre -129-el végtelen ciklus, míg -128-al semmi
            sem történik ebben a kódcsipetben rejlik, ami a java.lang.Integer
            osztályban található.
        </para>
        <para>
            Elsősorban mindenképpen tudni kell, hogy a !=, == operátorok az objektumok
            címét hasonlítják össze, valamint a Java feltételezi, hogy
            a programok sokat dolgoznak, majd kis számokkal,
            így a poolban már előre elkészített számok vannak 127-től -128-ig.
            Tehát amikor létrehozunk két Integer objektumot és az a poolon belül van,
            akkor a két objektum címe meg fog egyezni. Pontosan ez történik a -128-nál,
            lérehozzuk a két objektumot x-et és y-ot, azonban a poolból kapjuk meg
            mindkettőt egy már előre elkészített objektumot így a cím megegyezik.
            Ezért a x != y hamis értéket fog adni, így a while ciklus feltétele nem
            teljesül és nem jön létre végtelen ciklus.
        </para>
        <programlisting language="java">
        <![CDATA[return new Integer(i);]]>
        </programlisting>
        <para>
            Ha nem esik bele viszont a poolba a szám akkor, itt látszik, hogy létrehoz
            egy új Integert. Mivel a -129 nem esik bele így két különböző című objektumot
            fog létrehozni és így a while ciklus feltétele igaz lesz és végtelen
            ciklust kapunk.
        </para>
        
    </section>

    <section>
        <title>Yoda</title>
        <para>
            A feladat az volt, hogy írjunk egy olyan Java kódot ami NullPoinetException
            hibával kilép, ha nem követjük a Yoda conditionst. Íme a kód:
        </para>
        <programlisting language="java"><![CDATA[
public class Yoda {

    public static void main(String[] args) {
        
        String myString = null;
        
        if ("something".equals(myString)) {
            System.out.println("True");
        } else {
            System.out.println("False");
        }
        
        //NullPointer Exception
        if (myString.equals("something")) {
            System.out.println("True");
        } else {
            System.out.println("False");
        }
    }
}
        ]]></programlisting>
        <para> A Yoda conditions egy kódolási stílus, ahol a programkódot "fordítva" írjuk be, tehát
            az értékadásnál a konstans értéket írjuk balra és jobbra kerül a változó amibe
            elmentjük. A nevét is erről a szokatlan megfordított kódírásról kapta, Yoda-ról aki a
            Star Wars-ban hasonlóan nem szabályszerűen alkalmazza az angolt. </para>
        <programlisting language="java"><![CDATA[
int érték = 3;
if( érték == 3) {
    System.out.println("Igaz");
}
        ]]></programlisting>
        <para>
            Ez ahogy rendesen írnánk egy kódot.
        </para>
        <programlisting language="java"><![CDATA[
int érték = 3;
if( 3 == érték) {
    System.out.println("Igaz");
}
        ]]></programlisting>
        <para> Ugyanaz a kód Yoda conditions-t használva. Mindakettővel teljesen normálisan fog
            működni a program. </para>
        <programlisting language="java"><![CDATA[
if ("something".equals(myString)) {
    System.out.println("True");
} else {
    System.out.println("False");
}
        ]]></programlisting>
        <para>
            Ez a rész egy tipiuksan Yoda conditions-t használva lett megírva. Látszik,
            hogy az equal metódus bal oldalára került a konstans, jelen esetben egy
            string. Az equal ezt hasonlítja össze a myStringben lévő null értékkel.
            Ekkor semmilyen hiba nem fordul elő egyszerűen hamis lesz a visszadott érték.
        </para>
        <programlisting language="java"><![CDATA[
if (myString.equals("something")) {
    System.out.println("True");
} else {
    System.out.println("False");
}
        ]]></programlisting>
        <para>
            Ezek a sorok azonban nem használják a Yoda conditions-t, így NullPointerException-t
            dobnak a Java-ban. Így a Yoda conditions-al elkerülhető néhány nem biztonságos
            null viselkedés.
        </para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="yodajavacmd.jpg"/>
                </imageobject>
            </mediaobject>
        <para> Amint látszik a console-on is NullPointerException hibával kilép. </para>
        <para> Azonban a Yoda conditions bírálói nagyban panaszkodnak az olvashatóság elvesztésére,
            ha ezt a módszert alkalmazzuk. </para>
        
    </section>

    <section>
        <title>Kódolás from scratch</title>
        <para>
            valami
        </para>
    </section>       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
