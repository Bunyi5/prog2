<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Encoding</title>
        <para>
            A feladatban futtatni kellett a MandelbrotHalmazNagyító programot. Az volt benne
            a kihívás, hogy a forráskódban ékezetes karakterek is szerepeltek és ha fordítottuk
            akkor ezt a hibát kaptuk:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingerrorcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogy látszik a képen a kódolással lesz a hiba. Mivel az UTF-8-as kódolás számára
            nem találhatóak azok a karakterek amelyeket itt ? jelöl, ezek a kódban az ékezetes
            betűk.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodinggoodcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A megoldás az encoding kapcsoló volt rá a megfelelő kódolással. Kódolásnak pedig
            a Latin1 vagy Latin2 kellett megadni. Ezek a kódolások tartalmazzák az ékezetes betűket.
            Itt a Latin2 kellett használni, mert az tartalmazza az "ő" és "ű" is. Ennek a kódja pedig
            az ISO-8859-2 volt. Így már sikeresen fordult és futott is a program.
        </para>
        <para>
            A program futás közben:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingnagy.jpg" scale="95"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogyan felnagyítja a képet:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingkicsi.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>OOCWC lexer</title>
        <para>
            
        </para>
    </section>
    
    <section>
        <title>I334d1c4^5</title>
        <para>
            Olyan osztályt kellett írni, amely Leet chiperként működik. A Leet az egy másik
            angol ábécé, amit legfőképpen az interneten használnak. Az ASCII karakterek
            különféle kombinációját használja a latin betűk cseréjéhez. Legfőképpen az
            internetes fórumokon, chat-szobákban és online játékokban használják.
            Íme a kód:
        </para>
        <programlisting language="java">
<![CDATA[import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;

public class Leet {

    static String readFile(String path, Charset encoding) throws IOException {
        byte[] encoded = Files.readAllBytes(Paths.get(path));
        return new String(encoded, encoding);
    }
    
    static String translator(String text) {
        if (text.contains("a")) {
            text = text.replace("a","4");
        }
        if (text.contains("b")) {
            text = text.replace("b","8");
        }
        if (text.contains("c")) {
            text = text.replace("c","<");
        }
        if (text.contains("d")) {
            text = text.replace("d","|)");
        }
        if (text.contains("e")) {
            text = text.replace("e","3");
        }
        if (text.contains("f")) {
            text = text.replace("f","|=");
        }
        if (text.contains("g")) {
            text = text.replace("g","9");
        }
        if (text.contains("h")) {
            text = text.replace("h","#");
        }
        if (text.contains("i")) {
            text = text.replace("i","1");
        }
        if (text.contains("j")) {
            text = text.replace("j","_|");
        }
        if (text.contains("k")) {
            text = text.replace("k","|<");
        }
        if (text.contains("l")) {
            text = text.replace("l","|_");
        }
		if (text.contains("m")) {
            text = text.replace("m","|\\/|");
        }
        if (text.contains("n")) {
            text = text.replace("n","|\\|");
        }
        if (text.contains("o")) {
            text = text.replace("o","0");
        }
        if (text.contains("p")) {
            text = text.replace("p","|2");
        }
        if (text.contains("q")) {
            text = text.replace("q","(,)");
        }
        if (text.contains("r")) {
            text = text.replace("r","|?");
        }
        if (text.contains("s")) {
            text = text.replace("s","$");
        }
        if (text.contains("t")) {
            text = text.replace("t","7");
        }
		if (text.contains("u")) {
            text = text.replace("u","|_|");
        }
        if (text.contains("v")) {
            text = text.replace("v","\\/");
        }
        if (text.contains("w")) {
            text = text.replace("w","\\/\\/");
        }
        if (text.contains("x")) {
            text = text.replace("x","><");
        }
        if (text.contains("y")) {
            text = text.replace("y","´/");
        }
        if (text.contains("z")) {
            text = text.replace("z","2");
        }
        return text;      
    }
    
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("Kérem a fálj nevét: ");
        String fileName = scanner.nextLine();
        String fullFileContents = readFile(fileName,StandardCharsets.UTF_8);  
        System.out.println("File beolvasva.");
        fullFileContents = fullFileContents.toLowerCase();
        fullFileContents = translator(fullFileContents);
        System.out.println("File lefordítva.");
        
        PrintWriter writer = new PrintWriter("output.txt", "UTF-8");
        writer.print(fullFileContents);
        writer.close();
        System.out.println("A fordított szöveg az output.txt-ben megtalálható.");
        
        scanner.close();
    }
}]]>
        </programlisting>
        <para>
            A feladat megoldásához a legegyszerűbb megoldást alkalmaztam az if() függvényt.
        </para>
        <programlisting language="java">
<![CDATA[static String readFile(String path, Charset encoding) throws IOException {
    byte[] encoded = Files.readAllBytes(Paths.get(path));
    return new String(encoded, encoding);
}]]>
        </programlisting>
        <para>
            A readFile() metódussal először beolvasok egy szöveges fájlt. 
        </para>
        <programlisting language="java">
<![CDATA[static String translator(String text) {
    if (text.contains("a")) {
        text = text.replace("a","4");
    }
}]]>
        </programlisting>
        <para>
            A translator() metódusban történik a lényeg, a szöveget amit beolvastam átadom neki.
            Ekkor ha a szöveg tartalmaz egy bizonyos karakter, jelen esetben egy "a" betűt akkor
            mindenhol ahol "a" van a szövegben ott a replace() beípített metódussal kicserélem
            a karaktert egy "4"-esre.
        </para>
        <programlisting language="java">
<![CDATA[
public static void main(String[] args) throws IOException {
    Scanner scanner = new Scanner(System.in);
    
    System.out.print("Kérem a fálj nevét: ");
    String fileName = scanner.nextLine();
    String fullFileContents = readFile(fileName,StandardCharsets.UTF_8);  
    System.out.println("File beolvasva.");
    fullFileContents = fullFileContents.toLowerCase();
    fullFileContents = translator(fullFileContents);
    System.out.println("File lefordítva.");
    
    PrintWriter writer = new PrintWriter("output.txt", "UTF-8");
    writer.print(fullFileContents);
    writer.close();
    System.out.println("A fordított szöveg az output.txt-ben megtalálható.");
    
    scanner.close();
}
]]>
        </programlisting>
        <para>
            A main metóduson belül bekérem a beolvasandó fájl nevét, beolvasom a fájlt.
            Kisbetűssé alakítom, átadom a szöveget a translator() metódusnak. Majd
            kiírom egy külön fájlba a már átalakított szöveget.
        </para>
    </section>
    
    <section>
        <title>Full screen</title>
        <para>
            Egy Java-ban futó fullscreen-es programot kellett írnunk.
            Én egy bejelntkezési képernyőt írtam. Íme a kód:
        </para>
        <programlisting language="java">
<![CDATA[import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.*;

public class Login {
    
    public static void main(String[] args) {
        
        //Create, set buttons
        
        //Login button
        JButton login = new JButton("Login");
        login.setBounds(50, 300, 275, 50);
        
        //Exit button
        JButton exit = new JButton("Exit");
        exit.setBounds(375, 300, 275, 50);
        exit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });
        
        //Create, set labels
        
        //User name label
        JLabel username = new JLabel("Username:");
        username.setBounds(50, 50, 200, 75);
        username.setFont(new Font("Arial", Font.PLAIN, 40));
        
        //Password label
        JLabel password = new JLabel("Password:");
        password.setBounds(50, 150, 200, 75);
        password.setFont(new Font("Arial", Font.PLAIN, 40));
        
        //Create, set text fields
        
        //User text field
        JTextField userText = new JTextField();
        userText.setBounds(275, 55, 375, 60);
        
        //Pass text field
        JTextField passText = new JTextField();
        passText.setBounds(275, 155, 375, 60);
        
        //Create, set panel
        JPanel panel = new JPanel();
        
        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

        //Set panel
        int width = 700;
        int height = 400;
        panel.setBounds((dim.width-width)/2, (dim.height-height)/2, width, height);
        panel.setLayout(null);
        
        //Add buttons,labels,text fields to panel
        panel.add(login);
        panel.add(exit);
        panel.add(username);
        panel.add(password);
        panel.add(userText);
        panel.add(passText);
        
        //Create, set frame
        JFrame frame = new JFrame();
        frame.setExtendedState(Frame.MAXIMIZED_BOTH); //set width, height full
        frame.setUndecorated(true); // disable decorations on frame
        frame.getContentPane().setBackground(new Color(87, 147, 77));
        frame.setVisible(true); //show window
        frame.setLayout(null);
        
        //Add panel to frame
        frame.add(panel);
    }
}]]>
        </programlisting>
        <para> Nézzük meg részenként a kódot.</para>
        <programlisting language="java">
<![CDATA[//Create, set buttons

//Login button
JButton login = new JButton("Login");
login.setBounds(50, 300, 275, 50);

//Exit button
JButton exit = new JButton("Exit");
exit.setBounds(375, 300, 275, 50);
exit.addActionListener(new ActionListener() {
@Override
    public void actionPerformed(ActionEvent e) {
        System.exit(0);
    }
});]]>
        </programlisting>
        <para>
            Ennél a résznél létrehoztam a Login és Exit gombokat és megadtam az Exit
            gombnak, hogy kilépjen a programból, ha rákattintanak.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set labels

//User name label
JLabel username = new JLabel("Username:");
username.setBounds(50, 50, 200, 75);
username.setFont(new Font("Arial", Font.PLAIN, 40));

//Password label
JLabel password = new JLabel("Password:");
password.setBounds(50, 150, 200, 75);
password.setFont(new Font("Arial", Font.PLAIN, 40));]]>
        </programlisting>
        <para>
            Címkék létrehozása. Ezek tartalmazzák a username és password szöveget.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set text fields

//User text field
JTextField userText = new JTextField();
userText.setBounds(275, 55, 375, 60);

//Pass text field
JTextField passText = new JTextField();
passText.setBounds(275, 155, 375, 60);]]>
        </programlisting>
        <para>
            Létrehozom a mezőt ahová a user írhat.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set panel
JPanel panel = new JPanel();

Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

//Set panel
int width = 700;
int height = 400;
panel.setBounds((dim.width-width)/2, (dim.height-height)/2, width, height);
panel.setLayout(null);]]>
        </programlisting>
        <para>
            Egy panel létrehozása, ami magába fogja foglalni a gombokat, címkéket és text
            fieldeket.
        </para>
        <programlisting language="java">
<![CDATA[
//Add buttons,labels,text fields to panel
panel.add(login);
panel.add(exit);
panel.add(username);
panel.add(password);
panel.add(userText);
panel.add(passText);]]>
        </programlisting>
        <para>
            A panelhez hozzáadom a gombokat, címkéket, text fieldeket.
        </para>
        <programlisting language="java">
<![CDATA[
        //Create, set frame
        JFrame frame = new JFrame();
        frame.setExtendedState(Frame.MAXIMIZED_BOTH); //set width, height full
        frame.setUndecorated(true); // disable decorations on frame
        frame.getContentPane().setBackground(new Color(87, 147, 77));
        frame.setVisible(true); //show window
        frame.setLayout(null);
        
        //Add panel to frame
        frame.add(panel);
]]>
        </programlisting>
        <para>
            A lényegi rész pedig itt következik. Létrehozom a framet vagyis az ablakot.
            A setExtendedState-el maximalizálom a szélességét és hosszúságát az ablaknak.
            A setUndecorated(true)-val válik a program ténylegesen teljes képernyőssé.
            Ez "tünteti" el az ablak fejlécét, így fullscreen lesz a program.
        </para>
        <para>
            Az utolsó sorokban már csak színezés, megjelenítés van és hozzáadjuk a
            panelt a framehez. Így néz ki a program:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="fullscreen.JPG"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Paszigráfia Rapszódia OpenGL full screen vizualizáció</title>
        <para> A program első fordítása nem volt túl sikeres. Sok könyvtárat kellett leszednem
            ahhoz, hogy működjön: sudo apt-get install libglu1-mesa-dev freeglut3-dev
            mesa-common-dev. Ez a parancs telepítette nekem a glut könyvtárat ami hiányzott a
            fordításhoz. A fordításhoz a következő parancsot kellett használni: g++ para6.cpp -o
            para -lboost_system -lGL -lGLU -lglut -std=c++11. A futtatáshoz pedig ezt:
            <literallayout>
./para 3:2:1:1:0:3:2:1:0:2:0:2:1:1:0:3:3:0:2:0:1:1:0:1:0:1:0:1:
0:2:2:0:1:1:1:3:2:1:0:2:0:2:1:1:1:2:3:0:1:1:1:1:0:3:3:0:1:0:2:1
:0:1:0:2:2:0:0:0:1:3:1:0:1:3:2:1:0:2:0:3:3:0:1:0:2:1:0.
            </literallayout>
        </para>
        <para>
            A program elindításakor rögtön feltűnt, hogy a kocka a nyilakkal ellentétes
            irányba mozdul. Egy kis keresgélés után rá lehetett jönni, hogy ebben a metódusban
            kell változtatni, hogy jól működjön. Csak annyit kellett, hogy ahol hozzáadok
            ott kivonok az értékből, ahol pedig kivonok ott hozzáadok az értékhez. Így
            az ellenkező irányba fog mozdulni minden.
        </para>
        <programlisting language="java">
<![CDATA[void skeyboard ( int key, int x, int y )
{
    if ( key == GLUT_KEY_UP ) {
            cubeLetters[index].rotx -= 5.0;
    } else if ( key == GLUT_KEY_DOWN ) {
            cubeLetters[index].rotx += 5.0;
    } else if ( key == GLUT_KEY_RIGHT ) {
            cubeLetters[index].roty += 5.0;
    } else if ( key == GLUT_KEY_LEFT ) {
            cubeLetters[index].roty -= 5.0;
    } else if ( key == GLUT_KEY_PAGE_UP ) {
            cubeLetters[index].rotz -= 5.0;
    } else if ( key == GLUT_KEY_PAGE_DOWN ) {
            cubeLetters[index].rotz += 5.0;
    }

    glutPostRedisplay();
}]]>
        </programlisting>
        <para>
            A színezésssel játszadoztam még el. Ahhoz, hogy megváltoztassam a színét a
            glColor3f ( R, G, B) metóduson kellett módosítanom a programban. Ez lett
            a végeredmény:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="paszigrafia.jpg" scale="85"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
</chapter>
