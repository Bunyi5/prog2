<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Encoding</title>
        <para>
            A feladatban futtatni kellett a MandelbrotHalmazNagyító programot. Az volt benne
            a kihívás, hogy a forráskódban ékezetes karakterek is szerepeltek és ha fordítottuk
            akkor ezt a hibát kaptuk:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingerrorcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogy látszik a képen a kódolással lesz a hiba. Mivel az UTF-8-as kódolás számára
            nem találhatóak azok a karakterek amelyeket itt ? jelöl, ezek a kódban az ékezetes
            betűk.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodinggoodcmd.jpg"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            A megoldás az encoding kapcsoló volt rá a megfelelő kódolással. Kódolásnak pedig
            a Latin1 vagy Latin2 kellett megadni. Ezek a kódolások tartalmazzák az ékezetes betűket.
            Itt a Latin2 kellett használni, mert az tartalmazza az "ő" és "ű" is. Ennek a kódja pedig
            az ISO-8859-2 volt. Így már sikeresen fordult és futott is a program.
        </para>
        <para>
            A program futás közben:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingnagy.jpg" scale="95"></imagedata>
            </imageobject>
        </mediaobject>
        <para>
            Ahogyan felnagyítja a képet:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="encodingkicsi.jpg"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>I334d1c4^5</title>
        <para>
            Olyan osztályt kellett írni, amely Leet chiperként működik. A Leet az egy másik
            angol ábécé, amit legfőképpen az interneten használnak. Az ASCII karakterek
            különféle kombinációját használja a latin betűk cseréjéhez. Legfőképpen az
            internetes fórumokon, chat-szobákban és online játékokban használják.
            Íme a kód:
        </para>
        <programlisting language="java">
<![CDATA[import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;

public class LeetGood {
    
    private static char[] english_alphabet = {'a', 'b', 'c', 'd', 'e', 'f',
                                           'g', 'h', 'i', 'j', 'k', 'l',
                                           'm', 'n', 'o', 'p', 'q', 'r',
                                           's', 't', 'u', 'v', 'w', 'x',
                                           'y', 'z', ' '};
    
    private static String[] leet_alphabet = {"4", "8", "<", "|)", "3", "|=",
                                          "9", "#", "1", "_|", "|<",
                                          "|_", "|\\/|", "|\\|", "0",
                                          "|2", "(,)", "|?", "$", "7",
                                          "|_|", "\\/", "\\/\\/", "><",
                                          "´/", "2", " "};
    
    static String readFile(String path, Charset encoding) throws IOException {
        byte[] encoded = Files.readAllBytes(Paths.get(path));
        return new String(encoded, encoding);
    }
    
    static String translator(String word) {
        char[] wordArray = word.toCharArray();
        StringBuilder res = new StringBuilder();
        
        for (int i = 0; i < wordArray.length; i++) {
            for (int j = 0; j < english_alphabet.length; j++) {
                if (wordArray[i] == english_alphabet[j]) {
                    res.append(leet_alphabet[j]);
                    break;
                }
            }
        }
        return res.toString();
    }

    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("Kérem a fálj nevét: ");
        String fileName = scanner.nextLine();
        
        String fullFileContents = readFile(fileName,StandardCharsets.UTF_8);
        System.out.println("File beolvasva.");
        
        fullFileContents = fullFileContents.toLowerCase();
        fullFileContents = translator(fullFileContents);
        System.out.println("File lefordítva.");
        
        PrintWriter writer = new PrintWriter("leet.txt", "UTF-8");
        writer.print(fullFileContents);
        writer.close();
        System.out.println("A fordított szöveg az leet.txt-ben megtalálható.");
        
        scanner.close();
    }

}]]>
        </programlisting>
        <para>
            A feladat megoldásához tömböket alkalmaztam.
        </para>
        <programlisting language="java">
<![CDATA[private static char[] english_alphabet = {'a', 'b', 'c', 'd', 'e', 'f',
                                           'g', 'h', 'i', 'j', 'k', 'l',
                                           'm', 'n', 'o', 'p', 'q', 'r',
                                           's', 't', 'u', 'v', 'w', 'x',
                                           'y', 'z', ' '};

private static String[] leet_alphabet =  {"4", "8", "<", "|)", "3", "|=",
                                          "9", "#", "1", "_|", "|<",
                                          "|_", "|\\/|", "|\\|", "0",
                                          "|2", "(,)", "|?", "$", "7",
                                          "|_|", "\\/", "\\/\\/", "><",
                                          "´/", "2", " "};]]>
        </programlisting>
        <para>
            Létrehoztam egy char és egy String típusú tömböt. A char típusú tömbbe
            kimentettem az angol abc betűit, a String típusúba pedig ugyanarra a tömb
            pozícióba a neki megfelelő leet abc betűt.
        </para>
        <programlisting language="java">
<![CDATA[static String readFile(String path, Charset encoding) throws IOException {
    byte[] encoded = Files.readAllBytes(Paths.get(path));
    return new String(encoded, encoding);
}]]>
        </programlisting>
        <para>
            A readFile() metódus egy szöveges fájl beolvasására szolgál.
        </para>
        <programlisting language="java">
<![CDATA[static String translator(String word) {
    char[] wordArray = word.toCharArray();
    StringBuilder res = new StringBuilder();
    
    for (int i = 0; i < wordArray.length; i++) {
        for (int j = 0; j < english_alphabet.length; j++) {
            if (wordArray[i] == english_alphabet[j]) {
                res.append(leet_alphabet[j]);
                break;
            }
        }
    }
    return res.toString();
}]]>
        </programlisting>
        <para>
            A translator() metódusban történik a lényeg, a szöveget amit beolvastam átadom neki,
            majd átalakítom és kimentem egy char típúsú tömbbe. Példányosítok egy
            StringBuilder típusú változót, hogy egy szövegbe tudjam fűzni a leet abc betűit.
            Az első for ciklus végig lépked a tömb karakterein. A második for pedig az angol
            abc karakterein lépked. Ha a tömb karaktere és az angol abc karatere megegyezik
            akkor egy szövegbe fűzöm az angol abc-nek megfelelő leet abc betűt. Ha beléptem
            az if metódusba egy break-el megtöröm a belső for ciklust hiszen csak egyel
            lehet egyenlő így nem kell tovább néznem az abc betűit.
        </para>
        <programlisting language="java">
<![CDATA[public static void main(String[] args) throws IOException {
    Scanner scanner = new Scanner(System.in);
    
    System.out.print("Kérem a fálj nevét: ");
    String fileName = scanner.nextLine();
    
    String fullFileContents = readFile(fileName,StandardCharsets.UTF_8);
    System.out.println("File beolvasva.");
    
    fullFileContents = fullFileContents.toLowerCase();
    fullFileContents = translator(fullFileContents);
    System.out.println("File lefordítva.");
    
    PrintWriter writer = new PrintWriter("leet.txt", "UTF-8");
    writer.print(fullFileContents);
    writer.close();
    System.out.println("A fordított szöveg az leet.txt-ben megtalálható.");
    
    scanner.close();
}]]>
        </programlisting>
        <para>
            A main metóduson belül bekérem a beolvasandó fájl nevét, beolvasom a fájlt.
            Kisbetűssé alakítom, átadom a szöveget a translator() metódusnak. Majd
            kiírom egy külön fájlba a már átalakított szöveget.
        </para>
    </section>
    
    <section>
        <title>Full screen</title>
        <para>
            Egy Java-ban futó fullscreen-es programot kellett írnunk.
            Én egy bejelntkezési képernyőt írtam. Íme a kód:
        </para>
        <programlisting language="java">
<![CDATA[import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.*;

public class Login {
    
    public static void main(String[] args) {
        
        //Create, set buttons
        
        //Login button
        JButton login = new JButton("Login");
        login.setBounds(50, 300, 275, 50);
        
        //Exit button
        JButton exit = new JButton("Exit");
        exit.setBounds(375, 300, 275, 50);
        exit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });
        
        //Create, set labels
        
        //User name label
        JLabel username = new JLabel("Username:");
        username.setBounds(50, 50, 200, 75);
        username.setFont(new Font("Arial", Font.PLAIN, 40));
        
        //Password label
        JLabel password = new JLabel("Password:");
        password.setBounds(50, 150, 200, 75);
        password.setFont(new Font("Arial", Font.PLAIN, 40));
        
        //Create, set text fields
        
        //User text field
        JTextField userText = new JTextField();
        userText.setBounds(275, 55, 375, 60);
        
        //Pass text field
        JTextField passText = new JTextField();
        passText.setBounds(275, 155, 375, 60);
        
        //Create, set panel
        JPanel panel = new JPanel();
        
        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

        //Set panel
        int width = 700;
        int height = 400;
        panel.setBounds((dim.width-width)/2,
                            (dim.height-height)/2, width, height);
        panel.setLayout(null);
        
        //Add buttons,labels,text fields to panel
        panel.add(login);
        panel.add(exit);
        panel.add(username);
        panel.add(password);
        panel.add(userText);
        panel.add(passText);
        
        //Create, set frame
        JFrame frame = new JFrame();
        frame.setExtendedState(Frame.MAXIMIZED_BOTH);
        //set width, height full
        frame.setUndecorated(true); // disable decorations on frame
        frame.getContentPane().setBackground(new Color(87, 147, 77));
        frame.setVisible(true); //show window
        frame.setLayout(null);
        
        //Add panel to frame
        frame.add(panel);
    }
}]]>
        </programlisting>
        <para> Nézzük meg részenként a kódot.</para>
        <programlisting language="java">
<![CDATA[//Create, set buttons

//Login button
JButton login = new JButton("Login");
login.setBounds(50, 300, 275, 50);

//Exit button
JButton exit = new JButton("Exit");
exit.setBounds(375, 300, 275, 50);
exit.addActionListener(new ActionListener() {
@Override
    public void actionPerformed(ActionEvent e) {
        System.exit(0);
    }
});]]>
        </programlisting>
        <para>
            Ennél a résznél létrehoztam a Login és Exit gombokat és megadtam az Exit
            gombnak, hogy kilépjen a programból, ha rákattintanak.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set labels

//User name label
JLabel username = new JLabel("Username:");
username.setBounds(50, 50, 200, 75);
username.setFont(new Font("Arial", Font.PLAIN, 40));

//Password label
JLabel password = new JLabel("Password:");
password.setBounds(50, 150, 200, 75);
password.setFont(new Font("Arial", Font.PLAIN, 40));]]>
        </programlisting>
        <para>
            Címkék létrehozása. Ezek tartalmazzák a username és password szöveget.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set text fields

//User text field
JTextField userText = new JTextField();
userText.setBounds(275, 55, 375, 60);

//Pass text field
JTextField passText = new JTextField();
passText.setBounds(275, 155, 375, 60);]]>
        </programlisting>
        <para>
            Létrehozom a mezőt ahová a user írhat.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set panel
JPanel panel = new JPanel();

Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

//Set panel
int width = 700;
int height = 400;
panel.setBounds((dim.width-width)/2, (dim.height-height)/2, width, height);
panel.setLayout(null);]]>
        </programlisting>
        <para>
            Egy panel létrehozása, ami magába fogja foglalni a gombokat, címkéket és text
            fieldeket.
        </para>
        <programlisting language="java">
<![CDATA[//Add buttons,labels,text fields to panel
panel.add(login);
panel.add(exit);
panel.add(username);
panel.add(password);
panel.add(userText);
panel.add(passText);]]>
        </programlisting>
        <para>
            A panelhez hozzáadom a gombokat, címkéket, text fieldeket.
        </para>
        <programlisting language="java">
<![CDATA[//Create, set frame
JFrame frame = new JFrame();
frame.setExtendedState(Frame.MAXIMIZED_BOTH); //set width, height full
frame.setUndecorated(true); // disable decorations on frame
frame.getContentPane().setBackground(new Color(87, 147, 77));
frame.setVisible(true); //show window
frame.setLayout(null);

//Add panel to frame
frame.add(panel);]]>
        </programlisting>
        <para>
            A lényegi rész pedig itt következik. Létrehozom a framet vagyis az ablakot.
            A setExtendedState-el maximalizálom a szélességét és hosszúságát az ablaknak.
            A setUndecorated(true)-val válik a program ténylegesen teljes képernyőssé.
            Ez "tünteti" el az ablak fejlécét, így fullscreen lesz a program.
        </para>
        <para>
            Az utolsó sorokban már csak színezés, megjelenítés van és hozzáadjuk a
            panelt a framehez. Így néz ki a program:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="fullscreen.JPG"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
    
    <section>
        <title>Paszigráfia Rapszódia OpenGL full screen vizualizáció</title>
        <para> A program első fordítása nem volt túl sikeres. Sok könyvtárat kellett leszednem
            ahhoz, hogy működjön: sudo apt-get install libglu1-mesa-dev freeglut3-dev
            mesa-common-dev. Ez a parancs telepítette nekem a glut könyvtárat ami hiányzott a
            fordításhoz. A fordításhoz a következő parancsot kellett használni: g++ para6.cpp -o
            para -lboost_system -lGL -lGLU -lglut -std=c++11. A futtatáshoz pedig ezt:
            <literallayout>
./para 3:2:1:1:0:3:2:1:0:2:0:2:1:1:0:3:3:0:2:0:1:1:0:1:0:1:0:1:
0:2:2:0:1:1:1:3:2:1:0:2:0:2:1:1:1:2:3:0:1:1:1:1:0:3:3:0:1:0:2:1
:0:1:0:2:2:0:0:0:1:3:1:0:1:3:2:1:0:2:0:3:3:0:1:0:2:1:0.
            </literallayout>
        </para>
        <para>
            A program elindításakor rögtön feltűnt, hogy a kocka a nyilakkal ellentétes
            irányba mozdul. Egy kis keresgélés után rá lehetett jönni, hogy ebben a metódusban
            kell változtatni, hogy jól működjön. Csak annyit kellett, hogy ahol hozzáadok
            ott kivonok az értékből, ahol pedig kivonok ott hozzáadok az értékhez. Így
            az ellenkező irányba fog mozdulni minden.
        </para>
        <programlisting language="java">
<![CDATA[void skeyboard ( int key, int x, int y )
{
    if ( key == GLUT_KEY_UP ) {
            cubeLetters[index].rotx -= 5.0;
    } else if ( key == GLUT_KEY_DOWN ) {
            cubeLetters[index].rotx += 5.0;
    } else if ( key == GLUT_KEY_RIGHT ) {
            cubeLetters[index].roty += 5.0;
    } else if ( key == GLUT_KEY_LEFT ) {
            cubeLetters[index].roty -= 5.0;
    } else if ( key == GLUT_KEY_PAGE_UP ) {
            cubeLetters[index].rotz -= 5.0;
    } else if ( key == GLUT_KEY_PAGE_DOWN ) {
            cubeLetters[index].rotz += 5.0;
    }

    glutPostRedisplay();
}]]>
        </programlisting>
        <para>
            A színezésssel játszadoztam még el. Ahhoz, hogy megváltoztassam a színét a
            glColor3f ( R, G, B) metóduson kellett módosítanom a programban. Ez lett
            a végeredmény:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="paszigrafia.jpg" scale="85"></imagedata>
            </imageobject>
        </mediaobject>
    </section>
</chapter>
